// 🔹 LeetCode 3149. Sort Matrix by Diagonals
// Problem: https://leetcode.com/problems/sort-matrix-by-diagonals/

class Solution {
public:
    // Helper function to sort one diagonal of the matrix
    void SortMat(int r , int c, vector<vector<int>>& grid ,int n, bool ascending){
        int i = r, j = c;
        vector<int> vec;

        // collect all diagonal elements starting from (r, c)
        while(i < n && j < n){
            vec.push_back(grid[i][j]);
            i++; j++;
        }

        // sort diagonal in required order
        if(ascending)
            sort(vec.begin(), vec.end());
        else
            sort(vec.begin(), vec.end(), greater<int>());

        // put back sorted values into the grid
        i = r, j = c;
        for(auto &val : vec){
            grid[i][j] = val;
            i++; j++;
        }
    }

    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n = grid.size();

        // Intuition (in casual manner):
        // Think of the matrix as a bunch of diagonals.
        // Each diagonal (top-left → bottom-right) should be sorted,
        // but with a twist: 
        // - Diagonals starting from the first column go in DESC order.
        // - Diagonals starting from the first row go in ASC order.
        //
        // So the game plan is:
        // 1. For every row (starting at col=0), sort its diagonal in DESC.
        // 2. For every column (starting at row=0), sort its diagonal in ASC.
        //
        // This way, we process all diagonals exactly once.

        // sort diagonals starting from first column (row = 0..n-1) in DESC
        for(int row = 0; row < n; row++){
            SortMat(row, 0, grid, n, false);
        }

        // sort diagonals starting from first row (col = 1..n-1) in ASC
        for(int col = 1; col < n; col++){
            SortMat(0, col, grid, n, true);
        }

        return grid;
    }
};

// --------------------------------------------------
// ⏱️ Time Complexity: O(n^2 log n)
//    - There are O(2n) diagonals, each up to length n.
//    - Sorting each diagonal takes O(k log k), summed across diagonals → O(n^2 log n).
//
// 💾 Space Complexity: O(n) 
//    - For storing one diagonal in `vec` at a time.

// second appraoch:


class Solution {
public:
    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n = grid.size();
        unordered_map<int, vector<int>> mp;

        // Step 1: Group elements by their diagonals
        // Each diagonal can be uniquely identified by (i - j).
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int diag = i - j;
                mp[diag].push_back(grid[i][j]);
            }
        }

        // Step 2: Sort each diagonal according to rules
        // - If diagonal key >= 0 (starts from or below main diag) → ascending
        // - If diagonal key < 0 (above main diag) → descending
        for (auto& it : mp) {
            if (it.first >= 0) {
                sort(begin(it.second), end(it.second));  // ascending
            } else {
                sort(rbegin(it.second), rend(it.second)); // descending
            }
        }

        // Step 3: Put values back into the grid
        // We take values from the "back" because sorted order was stored,
        // and we want to place them from top-left → bottom-right correctly.
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int diag = i - j;
                grid[i][j] = mp[diag].back();
                mp[diag].pop_back();
            }
        }

        return grid;
    }
};

// --------------------------------------------------
// 💡 Intuition (casual):
// Instead of walking every diagonal separately, just bucket numbers
// by their diagonal index (i - j).
// Then sort each bucket:
//   - Diagonals starting on/below the main diagonal → ascending
//   - Diagonals above the main diagonal → descending
// Finally, fill the matrix back from these sorted buckets.
// Much cleaner than handling row/col starts manually!
//
// ⏱️ Time Complexity: O(n^2 log n)
//   - Each element belongs to exactly one diagonal.
//   - Sorting across all diagonals costs ~O(n^2 log n).
//
// 💾 Space Complexity: O(n^2)
//   - Extra storage in unordered_map for all matrix elements.
